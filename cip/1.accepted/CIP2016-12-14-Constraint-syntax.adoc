= CIP2016-12-16 - Constraints syntax
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Mats Rydberg <mats@neotechnology.com>

[abstract]
.Abstract
--
This CIP describes syntax and semantics for Cypher constraints.
These are language constructs that impose restrictions on the shape of the data graph, and how statements are allowed to change it.
--

toc::[]

== Motivation

Constraints provide the means by which various aspects of the data graph may be controlled.

== Background

Cypher has a loose notion of a schema, in which nodes and relationships may take very heterogeneous forms, both in terms of properties and in graph patterns.
Constraints allow us to mould the heterogeneous nature of the property graph into a more regular form.

== Proposal

This CIP includes the following proposed constraints:

* <<uniqueness>>
* <<existence, Node property existence constraint>>
* <<existence, Relationship property existence constraint>>

Each constraint is detailed in the sections below.

Once a constraint has been created, it may not be amended.
Should a user wish to change its definition, it has to be dropped and recreated with an updated structure.

==== Constraint names

All constraints require the user to specify a nonempty _name_ at constraint creation time.
This name is subsequently the handle with which a user may refer to the constraint, for example when dropping it.

// TODO: Should we impose restrictions on the domain of constraint names, or are all Unicode characters allowed?

=== Syntax overview

The syntax for all constraints follow the same basic outline.

.Grammar definition for constraint syntax.
[source, ebnf]
----
constraint command = create-constraint | drop-constraint ;
create-constraint  = "CREATE", "CONSTRAINT", constraint-name, "FOR", constraint-pattern, "REQUIRE", constraint-expr ;
constraint-name    = symbolic-name
constraint-pattern = node-pattern | simple-pattern ;
constraint-expr    = uniqueness-constraint | existence-constraint ;
drop-constraint    = "DROP", "CONSTRAINT", constraint-name ;
----

The constraint expressions vary depending on the actual constraint (see the detailed sections).

.Example of dropping a constraint with name `foo`:
[source, cypher]
----
DROP CONSTRAINT foo
----

=== Semantics overview

The following list describes the situations in which an error will be raised:

* Attempting to create a constraint on a graph where the data does not comply with the constraint criterion.
* Attempting to create a constraint with a name that already exists.
* Attempting to drop a constraint referencing a non-existent name.
* Attempting to modify the graph in such a way that it would violate a constraint.

The constraints define a _domain_ within which the constraint applies.
The domain is defined by the constraint pattern.

[[uniqueness]]
=== Node property uniqueness constraint

This constraint enforces that there cannot be duplicate values of some property `p` for any node labeled with some label `l`.
For example, this constraint can specify that the `email` property must be unique for all nodes labeled with `:Person`.

==== Syntax

.Grammar definition for the node property uniqueness constraint:
[source, ebnf]
----
uniqueness-constraint = "UNIQUE", property-expression, { ",", property-expression } ;
----

.Example of a single-property uniqueness constraint:
[source, cypher]
----
CREATE CONSTRAINT unique_person_email
FOR (p:Person)
REQUIRE UNIQUE p.email
----

.Example of a multiple-property uniqueness constraint:
[source, cypher]
----
CREATE CONSTRAINT unique_person_details
FOR (p:Person)
REQUIRE UNIQUE p.name, p.email, p.address
----

==== Semantics

The domain of a property uniqueness constraint is defined as all the nodes with a specific label where the specified property key(s) exist (i.e. are not null).
When more than one property key is defined as part of the constraint, only nodes where _all_ of the properties exist are part of the domain.

The uniqueness constraint mandates that two distinct nodes within the domain cannot have the same combination of values for the defined properties.

===== Example

Consider the graph created by the statement below.
The graph contains nodes labeled with `:Color`.
Each color is represented as an integer-type RGB value in a property `rgb`.
Users may look up nodes labeled with `:Color` to extract their RGB values for application processing.
Users may also add new `:Color`-labeled nodes to the graph.

[source, cypher]
----
CREATE (:Color {name: 'white', rgb: 0xffffff})
CREATE (:Color {name: 'black', rgb: 0x000000})
CREATE (:Color {name: 'very, very dark grey', rgb: 0x000000}) // rounding error!
----

Owing to the duplication of the `rgb` property, the following attempt at creating a constraint will fail:

[source, cypher]
----
CREATE CONSTRAINT only_one_color_per_rgb
FOR (c:Color)
REQUIRE UNIQUE c.rgb
----

Suppose that we would rather like to have one color node per `name` _and_ `rgb` value (to work around the rounding errors).
We could then use the following constraint, without modifying our data:

[source, cypher]
----
CREATE CONSTRAINT unique_color_nodes
FOR (c:Color)
REQUIRE UNIQUE c.rgb, c.name
----

[[existence]]
=== Property existence constraints

Property existence constraints are defined for both nodes and relationships; these have the same semantics.
We now describe both of these.

==== Syntax

.Grammar definition for the property existence constraint:
[source, ebnf]
----
existence-constraint = "exists", "(", property-expression, ")" ;
----

.Example of a node property existence constraint:
[source, cypher]
----
CREATE CONSTRAINT colors_must_have_rgb
FOR (c:Color)
REQUIRE exists(c.rgb)
----

.Example of a relationship property existence constraint:
[source, cypher]
----
CREATE CONSTRAINT rates_have_quality
FOR ()-[l:RATED]-()
REQUIRE exists(l.rating)
----

==== Semantics

The domain of a node property existence constraint are all nodes with the specified label.
Similarly, the domain of a relationship property existence constraint are all relationship with the specified type.

The property existence constraint mandates that the value of the specified property exists (i.e. is not null) for all entities in the domain.

===== Example

Consider once again the graph containing `:Color` nodes.

The following query retrieves the RGB value of a color with a given `name`:

[source, cypher]
----
MATCH (c:Color {name: $name})
WHERE exists(c.rgb)
RETURN c.rgb
----

The `WHERE` clause may be used to prevent an application from retrieving `null` values for user-defined colors where the RGB values have not been specified correctly.
It may, however, be eliminated by the introduction of a node property existence constraint:

[source, cypher]
----
CREATE CONSTRAINT colors_must_have_rgb
FOR (c:Color)
REQUIRE exists(c.rgb)
----

Any updating statement that would create a `:Color` node without specifying a `rgb` property for it would now fail.

=== Interaction with existing features

The main interaction between the constraints and the rest of the language occurs during updating statements.
Existing constraints will cause any updating statements to fail, thereby fulfilling the main purpose of this feature.

=== Alternatives

Alternative syntaxes have been discussed:

* `GIVEN`, `CONSTRAIN`, `ASSERT` instead of `FOR`
* `ASSERT`, `ENFORCE`, `IMPLIES` instead of `REQUIRE`

The use of an existing expression to express uniqueness -- instead of using a new keyword `UNIQUE` -- becomes unwieldy for multiple properties, as exemplified by the following:
----
FOR (p:Person), (q:Person)
REQUIRE p.email <> q.email AND p <> q
----

== What others do

In SQL, the following constraints exist (http://www.w3schools.com/sql/sql_constraints.asp):

* `NOT NULL` - Indicates that a column cannot store a null value.
* `UNIQUE` - Ensures that each row for a column must have a unique value.
* `PRIMARY KEY` - A combination of a `NOT NULL` and `UNIQUE`. Ensures that a column (or a combination of two or more columns) has a unique identity, reducing the resources required to locate a specific record in a table.
* `FOREIGN KEY` - Ensures the referential integrity of the data in one table matches values in another table.
* `CHECK` - Ensures that the value in a column meets a specific condition
* `DEFAULT` - Specifies a default value for a column.

The property existence constraints correspond to the `NOT NULL` SQL constraint.
The node property uniqueness constraint corresponds to the `PRIMARY KEY` SQL constraint.

SQL constraints may be introduced at table creation time in a `CREATE TABLE` statement, or in an `ALTER TABLE` statement:

.Creating a `Person` table in SQL Server / Oracle / MS Access:
[source, sql]
----
CREATE TABLE Person
(
   P_Id int NOT NULL UNIQUE,
   LastName varchar(255) NOT NULL,
   FirstName varchar(255))
----

.Creating a `Person` table in MySQL:
[source, sql]
----
CREATE TABLE Person
(
  P_Id int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255)
  UNIQUE (P_Id)
)
----

.Adding a named composite `UNIQUE` constraint in MySQL / SQL Server / Oracle / MS Access:
[source, sql]
----
ALTER TABLE Person
ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)
----

== Benefits to this proposal

Constraints make Cypher's notion of schema more well-defined, allowing users to maintain graphs in a more regular, easier-to-manage form.

== Caveats to this proposal

Some constraints may prove challenging to enforce in a system seeking to implement the contents of this CIP, as these generally require scanning through large parts of the graph to locate conflicting entities.
