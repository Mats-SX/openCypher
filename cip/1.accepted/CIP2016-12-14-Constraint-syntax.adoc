= CIP2016-12-16 - Constraints syntax
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Mats Rydberg <mats@neotechnology.com>

[abstract]
.Abstract
--
This CIP describes syntax and semantics for Cypher constraints.
These are language constructs that impose restrictions on the shape of the data graph, and how statements are allowed to change it.
--

toc::[]

== Background

Cypher has a loose notion of a schema, in which nodes and relationships may take very heterogeneous forms, both in terms of properties and in graph patterns.
Constraints allow us to mould the heterogeneous nature of the property graph into a more regular form.

== Proposal

This CIP specifies the general syntax for constraint definition (and constraint removal), and provides several examples of possible use cases for constraints.
However, the specification does not otherwise specify or limit the space of expressible constraints that the syntax and semantics allow.

===== Mutability

Once a constraint has been created, it may not be amended.
Should a user wish to change its definition, it has to be dropped and recreated with an updated structure.

===== Constraint names

All constraints require the user to specify a nonempty _name_ at constraint creation time.
This name is subsequently the handle with which a user may refer to the constraint, for example when dropping it.

// TODO: Should we impose restrictions on the domain of constraint names, or are all Unicode characters allowed?

=== Syntax

The constraint syntax is defined as follows:

.Grammar definition for constraint syntax.
[source, ebnf]
----
constraint command = create-constraint | drop-constraint ;
create-constraint  = "CREATE", "CONSTRAINT", constraint-name, "FOR", constraint-pattern, "REQUIRE", constraint-expr, { "REQUIRE", constraint-expr } ;
constraint-name    = symbolic-name
constraint-pattern = node-pattern | simple-pattern ;
constraint-expr    = uniqueness-expr | expression ;
uniquness-expr     = "UNIQUE", property-expression, { ",", property-expression }
drop-constraint    = "DROP", "CONSTRAINT", constraint-name ;
----

The constraint expression (`constraint-expr` above) is any expression that evaluates to a boolean value.
This allows for very complex concrete constraint definitions within the specified syntax.

To that set of valid expressions, this CIP further specifies a special prefix operator `UNIQUE`, which is used to assert uniqueness of one or more property expressions.

==== Removing constraints

A constraint is removed by referring to its name.

.Example of dropping a constraint with name `foo`:
[source, cypher]
----
DROP CONSTRAINT foo
----

=== Semantics

The semantics for constraints follow these general rules:

1. The constraint pattern define the constraint domain, where all entities that would be returned by a `MATCH` clause with the same pattern constitute the domain, with one notable exception (see <<domain-exception, 3.>>).

2. The constraint expressions defined in the `REQUIRE` clauses of the constraint definition must all evaluate to `true`. Any other result raises an error (see <<Errors>>).

3. [[domain-exception]]Entities for which a constraint expression evaluate to `null` under Cypher's ternary logic are _excluded_ from the constraint domain, even if they fit within the constraint pattern.

==== Uniqueness

The new operator `UNIQUE` is only valid as part of a constraint expression.
It takes as argument one or more property expressions, and asserts that the combination of the evaluated values of the expressions (forming a tuple) is unique across the constraint domain.

The domain of the uniqueness expression is limited to entities for which _all_ properties defined as arguments to the `UNIQUE` operator exist.
In other words, property expressions which evaluate to `null` are not considered for uniqueness (see <<domain-exception,3.>>) above.

.Example of a constraint definition using `UNIQUE`, over the domain of nodes labeled with `:Person`:
[source, cypher]
----
CREATE CONSTRAINT unique_person_details
FOR (p:Person)
REQUIRE UNIQUE p.name, p.email, p.address
----

==== Errors

The following list describes the situations in which an error will be raised:

* Attempting to create a constraint on a graph where the data does not comply with the constraint criterion.
* Attempting to create a constraint with a name that already exists.
* Attempting to drop a constraint referencing a non-existent name.
* Attempting to modify the graph in such a way that it would violate a constraint.

The constraints define a _domain_ within which the constraint applies.
The domain is defined by the constraint pattern.

==== Compositionality

It is possible to define multiple `REQUIRE` clauses within the scope of the same constraint.
The semantics between these is that of a conjunction between the constraint expressions of the clauses, such that the constraint is upheld if and only if for all `REQUIRE` clauses, the expression evaluates to `true`.

This is useful not only for readability and logical separation of different aspects of the same constraint, but also for combining the use of the `UNIQUE` operator with other constraint expressions.

=== Examples

In this section we provide several examples of constraints that are possible to express in the specified syntax.

[NOTE]
The specification in this CIP is limited to the general syntax of constraints, and the following are simply examples of possible uses of the language defined by that syntax. None of the examples provided are to be viewed as mandatory for any Cypher implementation.

Consider the graph created by the statement below.
The graph contains nodes labeled with `:Color`.
Each color is represented as an integer-type RGB value in a property `rgb`.
Users may look up nodes labeled with `:Color` to extract their RGB values for application processing.
Users may also add new `:Color`-labeled nodes to the graph.

[source, cypher]
----
CREATE (:Color {name: 'white', rgb: 0xffffff})
CREATE (:Color {name: 'black', rgb: 0x000000})
CREATE (:Color {name: 'very, very dark grey', rgb: 0x000000}) // rounding error!
----

Owing to the duplication of the `rgb` property, the following attempt at creating a constraint will fail:

[source, cypher]
----
CREATE CONSTRAINT only_one_color_per_rgb
FOR (c:Color)
REQUIRE UNIQUE c.rgb
----

Suppose that we would rather like to have one color node per `name` _and_ `rgb` value (to work around the rounding errors).
We could then use the following constraint, without modifying our data:

[source, cypher]
----
CREATE CONSTRAINT unique_color_nodes
FOR (c:Color)
REQUIRE UNIQUE c.rgb, c.name
----

Now, consider the following query which retrieves the RGB value of a color with a given `name`:

[source, cypher]
----
MATCH (c:Color {name: $name})
WHERE exists(c.rgb)
RETURN c.rgb
----

The `WHERE` clause is here used to prevent an application from retrieving `null` values for user-defined colors where the RGB values have not been specified correctly.
It may, however, be eliminated by the introduction of a constraint asserting the existence of that property:

[source, cypher]
----
CREATE CONSTRAINT colors_must_have_rgb
FOR (c:Color)
REQUIRE exists(c.rgb)
----

Any updating statement that would create a `:Color` node without specifying an `rgb` property for it would now fail.

Alternatively, we could extend our previous constraint definition with this new requirement:

[source, cypher]
----
CREATE CONSTRAINT color_schema
FOR (c:Color)
REQUIRE UNIQUE c.rgb, c.name
REQUIRE exists(c.rgb)
----

This composite constraint will make sure that all `:Color` nodes has a value for their `rgb` property, and that its value is unique for each `name`.

More complex constraint definitions are considered below:

.Property value limitations
[source, cypher]
----
CREATE CONSTRAINT road_width
FOR ()-[r:ROAD]-()
REQUIRE 5 < r.width < 50
----

.Cardinality
[source, cypher]
----
CREATE CONSTRAINT spread_the_love
FOR (p:Person)
REQUIRE size((p)-[:LOVES]->()) > 3
----

.Endpoint requirements
[source, cypher]
----
CREATE CONSTRAINT can_only_own_things
FOR ()-[:OWNS]->(t)
REQUIRE (t:Vehicle) OR (t:Building) OR (t:Object)
----

.Label coexistence
[source, cypher]
----
CREATE CONSTRAINT programmers_are_people_too
FOR (p:Programmer)
REQUIRE p:Person
----

=== Interaction with existing features

The main interaction between the constraints and the rest of the language occurs during updating statements.
Existing constraints will cause any updating statements to fail, thereby fulfilling the main purpose of this feature.

=== Alternatives

Alternative syntaxes have been discussed:

* `GIVEN`, `CONSTRAIN`, `ASSERT` instead of `FOR`
* `ASSERT`, `ENFORCE`, `IMPLIES` instead of `REQUIRE`

The use of an existing expression to express uniqueness -- instead of using the operator `UNIQUE` -- becomes unwieldy for multiple properties, as exemplified by the following:
----
FOR (p:Person), (q:Person)
REQUIRE p.email <> q.email AND p <> q
----

== What others do

In SQL, the following constraints exist (inspired by http://www.w3schools.com/sql/sql_constraints.asp):

* `NOT NULL` - Indicates that a column cannot store a null value.
* `UNIQUE` - Ensures that each row for a column must have a unique value.
* `PRIMARY KEY` - A combination of a `NOT NULL` and `UNIQUE`. Ensures that a column (or a combination of two or more columns) has a unique identity, reducing the resources required to locate a specific record in a table.
* `FOREIGN KEY` - Ensures the referential integrity of the data in one table matches values in another table.
* `CHECK` - Ensures that the value in a column meets a specific condition
* `DEFAULT` - Specifies a default value for a column.

The property existence constraints correspond to the `NOT NULL` SQL constraint.
The node property uniqueness constraint corresponds to the `PRIMARY KEY` SQL constraint.

SQL constraints may be introduced at table creation time in a `CREATE TABLE` statement, or in an `ALTER TABLE` statement:

.Creating a `Person` table in SQL Server / Oracle / MS Access:
[source, sql]
----
CREATE TABLE Person
(
   P_Id int NOT NULL UNIQUE,
   LastName varchar(255) NOT NULL,
   FirstName varchar(255))
----

.Creating a `Person` table in MySQL:
[source, sql]
----
CREATE TABLE Person
(
  P_Id int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255)
  UNIQUE (P_Id)
)
----

.Adding a named composite `UNIQUE` constraint in MySQL / SQL Server / Oracle / MS Access:
[source, sql]
----
ALTER TABLE Person
ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)
----

== Benefits to this proposal

Constraints make Cypher's notion of schema more well-defined, allowing users to maintain graphs in a more regular, easier-to-manage form.

Additionally, this specification is deliberately defining a constraint _language_ within which a great deal of possible concrete constraints are made possible.
This allows different implementers of Cypher to independently choose how to limit the scope of supported constraint expressions that fit their model and targeted use cases.

== Caveats to this proposal

Some constraints may prove challenging to enforce in a system seeking to implement the contents of this CIP, as these generally require scanning through large parts of the graph to locate conflicting entities.
