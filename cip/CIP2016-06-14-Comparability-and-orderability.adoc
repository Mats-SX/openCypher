= CIP2016-06-14 - Comparability and Orderability
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Mats Rydberg <mats@neotechnology.com>, Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP intends to introduce and formalise two new concepts, *orderability* and *comparability*, and defines their relationship to the already existing concepts of *equality* and *equivalence*.
Orderability revolves around the `ORDER BY` clause, and defines the semantics it needs to be able to properly sort values passed to it.
Comparability revolves around the inequality operators (`>`, `<`, `>=`, `<=`), and defines the semantics they need to properly determine how two values compare to each other.
In order to get a consistent set of rules, we are proposing some changes to how Cypher defines these concepts.
--

toc::[]


== Motivation

There are currently a number of limitations and inconsistencies that this CIP will try to fix.

- `ORDER BY` will fail with an error if the values passed to it have different types.
- Various inconsistencies around equality semantics as exposed by `IN`, `=`, `DISTINCT`, and grouping
- Unclear relationship between comparison operators, equality, and `ORDER BY`

The difference between equality and equivalence in Cypher today is small and subtle, and limited to testing two instances of the value `null` to each other.

- In equality, `null = null` is `null`
- In equivalence, used by grouping and `DISTINCT`, instances of `null` are treated as being the same value

This proposal aims to increase the difference between these two concepts, by making lists containing `null` values follow the same difference as the `null` values themselves.

== Proposal

Currently, Cypher has good semantics for equality within the primitive types (booleans, strings, integers, and floats) and maps.
Furthermore, Cypher has good semantics for comparability and orderability for integers, floats, and strings, within the types.
Between different types, however, the comparability is undefined, which is something we regard as a problem for certain combinations of values and types. Also comparability and orderability are not aligned with each other consistently

We propose that comparability be defined between any pair of values, where the result of a comparison is `null`, unless otherwise specified.

- Integers are compared according to their natural ordering.
- Floats (excluding `NaN`s) are compared according to their natural ordering. Infinities are the highest/lowest values respectively.
- Integers and floats are compared to each other according to their natural ordering.
- Comparing any number to a `NaN` always yields `NaN`.
- Booleans are compared such that `false < true`.
- Strings are compared in dictionary order, i.e. characters are compared pairwise in order and characters missing in a shorter string are considered to be smaller than any other character. For example, `'a' < 'aa'`.
- Lists are compared in dictionary order, i.e. list elements are compared pairwise in order and elements missing in a shorter list are considered to be smaller than any other value. For example, `[1] < [1,0]`.
- Maps are compared as if they where lists of lists, where the inner lists are the key-value pairs of the maps, ordered in ascending sort order for the keys and omitting map entries where the value is `null`. Comparing a map to a value that is not a map always yields 'null'.
- The comparison order for nodes (and relationships resp.) is undefined, and an implementation may choose an order for these freely, e.g. by using some kind of id. This order must not change during the execution of the query (i.e. it must be stable in the presence of updates). Comparing a node to a relationship always yields 'null'.
- Paths are compared as if they where a list of alternating nodes and relationships of the path from the start node to the end node. Comparing a path to a value that is not a path always yields 'null'.
- Comparing any other combination of values of different types would yield `null` (meaning "unknown" in the context of comparability).

We further propose that orderability be defined between any pair of values, where the result is always `true` or `false`; i.e. always defined.
To accomplish this, there must be a pre-determined type order and each value must fall under exactly one type in this order. We propose to use the following ascending global sort order:

- `NODE`
- `RELATIONSHIP`
- `PATH`
- `MAP`
- `LIST OF ANY?`
- `STRING`
- `BOOLEAN`
- `NUMBER` (`NaN` is treated as the largest number in orderability, i.e. it is put after positive infinity)
- `VOID` (i.e. `null`)

Within the types, orderability defers to comparability.

The accompanying descending global sort oder is the same order in reverse (i.e. it runs from `VOID` to `NODE`).

Finally, we propose to redefine how equality works for lists in Cypher today.
The main issue is how Cypher deals with lists that contain the `null` value.
To determine if two lists `l1` and `l2` are equal, we propose two simple tests, like so

- `l1` and `l2` must have the same size, i.e. inversely `size(l1) <> size(l2>) => l1 <> l2`
- the pairwise elements of both `l1` and `l2` must be equal, i.e.
----
[a1, a2, ...] = [b1, b2, ...]
<=>
a1 = b1 && a2 = b2 && ...
----

=== Examples

An integer compared to a float
[source, cypher]
----
RETURN 1 > 0.5 // should be true
----

A string compared to a boolean
[source, cypher]
----
RETURN 'string' <= true // should be null
----

Ordering values of different types
[source, cypher]
----
UNWIND [1, true, '', 3.14, {}, [2]] AS i
RETURN i
  ORDER BY i // should not crash
----

Filtering distinct values of different types
[source, cypher]
----
UNWIND [[null], [null]] AS i
RETURN DISTINCT i // should return exactly one row
----

=== Interaction with existing features

The concept of orderability is used only by `ORDER BY` in Cypher today.
The concept of comparability is used by the comparisons operators `<`, `>`, `<=`, >=`.

One major goal of our proposal is for equality semantics to align well with comparability.
The concept of equality is used by the equality operator `=`, the inequality operator `<>`, value joins, and the `IN` operator.
The concept of equivalence is used by the `DISTINCT` clause modifier and in grouping.

With the proposals made in this CIP, specifically changing equality for lists, the mentioned functionality is going to treat lists containing `null` as unequal, thus potentially filtering out more rows when used in a predicate.

=== Alternatives

This proposal could be extended with an operator for making equivalence accessible beyond use in grouping and `DISTINCT`.

== Benefits to this proposal

A consistent set of rules for equality, equivalence, comparability and orderability.

== Caveats to this proposal

Adopting this proposal may break some queries; specifically queries that depend on equality semantics of lists containing nulls.
It should be noted that we expect that most lists used in queries are constructed using `collect()`, which never outputs nulls.

=== Appendix: Comparability by Type

The following table captures which types may be compared with each other such that the outcome is either `true` or `false`.
Any other comparison will always yield `null` (except for `NaN`) which is handled as described above.

.Comparability by type
[frame="topbot",options="header,footer"]
|===========================================================================================================================================
|Type           | `NODE` | `RELATIONSHIP` | `PATH` | `MAP` | `LIST OF ANY?` | `STRING` | `BOOLEAN` | `NUMBER` | `INTEGER` | `FLOAT` | `VOID`
|`NODE`         | X      |                |        |       |                |          |           |          |           |         |
|`RELATIONSHIP` |        | X              |        |       |                |          |           |          |           |         |
|`PATH`         |        |                | X      |       |                |          |           |          |           |         |
|`MAP`          |        |                |        | X     |                |          |           |          |           |         |
|`LIST OF ANY?` |        |                |        |       | X              |          |           |          |           |         |
|`STRING`       |        |                |        |       |                | X        |           |          |           |         |
|`BOOLEAN`      |        |                |        |       |                |          | X         |          |           |         |
|`NUMBER`       |        |                |        |       |                |          |           | X        | X         | X       |
|`INTEGER`      |        |                |        |       |                |          |           | X        | X         | X       |
|`FLOAT`        |        |                |        |       |                |          |           | X        | X         | X       |
|`VOID`         |        |                |        |       |                |          |           |          |           |         |
|===========================================================================================================================================
`
